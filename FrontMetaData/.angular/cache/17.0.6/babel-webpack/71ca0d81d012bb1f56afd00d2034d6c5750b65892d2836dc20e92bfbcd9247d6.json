{"ast":null,"code":"import { HttpResponse } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, mergeMap, materialize, dematerialize } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nexport class FakeBackendInterceptor {\n  constructor() {}\n  intercept(request, next) {\n    // array in local storage for registered users\n    // tslint:disable-next-line: max-line-length\n    const users = JSON.parse(localStorage.getItem('users')) || [{\n      username: 'admin',\n      email: 'admin@themesdesign.in',\n      password: '123456'\n    }];\n    // wrap in delayed observable to simulate server api call\n    return of(null).pipe(mergeMap(() => {\n      // authenticate\n      if (request.url.endsWith('/users/authenticate') && request.method === 'POST') {\n        const filteredUsers = users.filter(user => {\n          return user.email === request.body.email && user.password === request.body.password;\n        });\n        if (filteredUsers.length) {\n          // if login details are valid return 200 OK with user details and fake jwt token\n          const user = filteredUsers[0];\n          const body = {\n            id: user.id,\n            email: user.email,\n            username: user.username,\n            firstName: user.firstName,\n            lastName: user.lastName,\n            token: 'fake-jwt-token'\n          };\n          return of(new HttpResponse({\n            status: 200,\n            body\n          }));\n        } else {\n          // else return 400 bad request\n          return throwError({\n            error: {\n              message: 'Username or password is incorrect'\n            }\n          });\n        }\n      }\n      // get users\n      if (request.url.endsWith('/users') && request.method === 'GET') {\n        // tslint:disable-next-line: max-line-length\n        // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\n        if (request.headers.get('Authorization') === 'Bearer fake-jwt-token') {\n          return of(new HttpResponse({\n            status: 200,\n            body: users\n          }));\n        } else {\n          // return 401 not authorised if token is null or invalid\n          return throwError({\n            status: 401,\n            error: {\n              message: 'Unauthorised'\n            }\n          });\n        }\n      }\n      // get user by id\n      if (request.url.match(/\\/users\\/\\d+$/) && request.method === 'GET') {\n        // tslint:disable-next-line: max-line-length\n        // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n        if (request.headers.get('Authorization') === 'Bearer fake-jwt-token') {\n          // find user by id in users array\n          const urlParts = request.url.split('/');\n          // tslint:disable-next-line: radix\n          const id = parseInt(urlParts[urlParts.length - 1]);\n          // tslint:disable-next-line: no-shadowed-variable\n          const matchedUsers = users.filter(user => user.id === id);\n          const user = matchedUsers.length ? matchedUsers[0] : null;\n          return of(new HttpResponse({\n            status: 200,\n            body: user\n          }));\n        } else {\n          // return 401 not authorised if token is null or invalid\n          return throwError({\n            status: 401,\n            error: {\n              message: 'Unauthorised'\n            }\n          });\n        }\n      }\n      // register user\n      if (request.url.endsWith('/users/register') && request.method === 'POST') {\n        // get new user object from post body\n        const newUser = request.body;\n        // validation\n        const duplicateUser = users.filter(user => user.username === newUser.username).length;\n        if (duplicateUser) {\n          return throwError({\n            error: {\n              message: 'Username \"' + newUser.username + '\" is already taken'\n            }\n          });\n        }\n        // save new user\n        newUser.id = users.length + 1;\n        users.push(newUser);\n        localStorage.setItem('users', JSON.stringify(users));\n        // respond 200 OK\n        return of(new HttpResponse({\n          status: 200\n        }));\n      }\n      // delete user\n      if (request.url.match(/\\/users\\/\\d+$/) && request.method === 'DELETE') {\n        // tslint:disable-next-line: max-line-length\n        // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n        if (request.headers.get('Authorization') === 'Bearer fake-jwt-token') {\n          // find user by id in users array\n          const urlParts = request.url.split('/');\n          // tslint:disable-next-line: radix\n          const id = parseInt(urlParts[urlParts.length - 1]);\n          for (let i = 0; i < users.length; i++) {\n            const user = users[i];\n            if (user.id === id) {\n              // delete user\n              users.splice(i, 1);\n              localStorage.setItem('users', JSON.stringify(users));\n              break;\n            }\n          }\n          // respond 200 OK\n          return of(new HttpResponse({\n            status: 200\n          }));\n        } else {\n          // return 401 not authorised if token is null or invalid\n          return throwError({\n            status: 401,\n            error: {\n              message: 'Unauthorised'\n            }\n          });\n        }\n      }\n      // pass through any requests not handled above\n      return next.handle(request);\n    }))\n    // tslint:disable-next-line: max-line-length\n    // call materialize and dematerialize to ensure delay even if an error is thrown (https://github.com/Reactive-Extensions/RxJS/issues/648)\n    .pipe(materialize()).pipe(delay(500)).pipe(dematerialize());\n  }\n  static #_ = this.ɵfac = function FakeBackendInterceptor_Factory(t) {\n    return new (t || FakeBackendInterceptor)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FakeBackendInterceptor,\n    factory: FakeBackendInterceptor.ɵfac\n  });\n}","map":{"version":3,"names":["HttpResponse","of","throwError","delay","mergeMap","materialize","dematerialize","FakeBackendInterceptor","constructor","intercept","request","next","users","JSON","parse","localStorage","getItem","username","email","password","pipe","url","endsWith","method","filteredUsers","filter","user","body","length","id","firstName","lastName","token","status","error","message","headers","get","match","urlParts","split","parseInt","matchedUsers","newUser","duplicateUser","push","setItem","stringify","i","splice","handle","_","_2","factory","ɵfac"],"sources":["C:\\PIDataCatalogDREAMIT\\FrontMetaData\\src\\app\\core\\helpers\\fake-backend.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpRequest, HttpResponse, HttpHandler, HttpEvent, HttpInterceptor, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { Observable, of, throwError } from 'rxjs';\nimport { delay, mergeMap, materialize, dematerialize } from 'rxjs/operators';\n\n@Injectable()\nexport class FakeBackendInterceptor implements HttpInterceptor {\n\n    constructor() { }\n\n    intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n        // array in local storage for registered users\n        // tslint:disable-next-line: max-line-length\n        const users: any[] = JSON.parse(localStorage.getItem('users')) || [{ username: 'admin', email: 'admin@themesdesign.in', password: '123456' }];\n\n        // wrap in delayed observable to simulate server api call\n        return of(null).pipe(mergeMap(() => {\n\n            // authenticate\n            if (request.url.endsWith('/users/authenticate') && request.method === 'POST') {\n                const filteredUsers = users.filter(user => {\n                    return user.email === request.body.email && user.password === request.body.password;\n                });\n                if (filteredUsers.length) {\n                    // if login details are valid return 200 OK with user details and fake jwt token\n                    const user = filteredUsers[0];\n                    const body = {\n                        id: user.id,\n                        email: user.email,\n                        username: user.username,\n                        firstName: user.firstName,\n                        lastName: user.lastName,\n                        token: 'fake-jwt-token'\n                    };\n\n                    return of(new HttpResponse({ status: 200, body }));\n                } else {\n                    // else return 400 bad request\n                    return throwError({ error: { message: 'Username or password is incorrect' } });\n                }\n            }\n\n            // get users\n            if (request.url.endsWith('/users') && request.method === 'GET') {\n                // tslint:disable-next-line: max-line-length\n                // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\n                if (request.headers.get('Authorization') === 'Bearer fake-jwt-token') {\n                    return of(new HttpResponse({ status: 200, body: users }));\n                } else {\n                    // return 401 not authorised if token is null or invalid\n                    return throwError({ status: 401, error: { message: 'Unauthorised' } });\n                }\n            }\n\n            // get user by id\n            if (request.url.match(/\\/users\\/\\d+$/) && request.method === 'GET') {\n                // tslint:disable-next-line: max-line-length\n                // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n                if (request.headers.get('Authorization') === 'Bearer fake-jwt-token') {\n                    // find user by id in users array\n                    const urlParts = request.url.split('/');\n                    // tslint:disable-next-line: radix\n                    const id = parseInt(urlParts[urlParts.length - 1]);\n                    // tslint:disable-next-line: no-shadowed-variable\n                    const matchedUsers = users.filter(user => user.id === id);\n                    const user = matchedUsers.length ? matchedUsers[0] : null;\n\n                    return of(new HttpResponse({ status: 200, body: user }));\n                } else {\n                    // return 401 not authorised if token is null or invalid\n                    return throwError({ status: 401, error: { message: 'Unauthorised' } });\n                }\n            }\n\n            // register user\n            if (request.url.endsWith('/users/register') && request.method === 'POST') {\n                // get new user object from post body\n                const newUser = request.body;\n\n                // validation\n                const duplicateUser = users.filter(user => user.username === newUser.username).length;\n                if (duplicateUser) {\n                    return throwError({ error: { message: 'Username \"' + newUser.username + '\" is already taken' } });\n                }\n\n                // save new user\n                newUser.id = users.length + 1;\n                users.push(newUser);\n                localStorage.setItem('users', JSON.stringify(users));\n\n                // respond 200 OK\n                return of(new HttpResponse({ status: 200 }));\n            }\n\n            // delete user\n            if (request.url.match(/\\/users\\/\\d+$/) && request.method === 'DELETE') {\n                // tslint:disable-next-line: max-line-length\n                // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n                if (request.headers.get('Authorization') === 'Bearer fake-jwt-token') {\n                    // find user by id in users array\n                    const urlParts = request.url.split('/');\n                    // tslint:disable-next-line: radix\n                    const id = parseInt(urlParts[urlParts.length - 1]);\n                    for (let i = 0; i < users.length; i++) {\n                        const user = users[i];\n                        if (user.id === id) {\n                            // delete user\n                            users.splice(i, 1);\n                            localStorage.setItem('users', JSON.stringify(users));\n                            break;\n                        }\n                    }\n\n                    // respond 200 OK\n                    return of(new HttpResponse({ status: 200 }));\n                } else {\n                    // return 401 not authorised if token is null or invalid\n                    return throwError({ status: 401, error: { message: 'Unauthorised' } });\n                }\n            }\n\n            // pass through any requests not handled above\n            return next.handle(request);\n\n        }))\n\n            // tslint:disable-next-line: max-line-length\n            // call materialize and dematerialize to ensure delay even if an error is thrown (https://github.com/Reactive-Extensions/RxJS/issues/648)\n            .pipe(materialize())\n            .pipe(delay(500))\n            .pipe(dematerialize());\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}